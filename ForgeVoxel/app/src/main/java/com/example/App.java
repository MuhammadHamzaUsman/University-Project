/*
 * This source file was generated by the Gradle 'init' task
 */
package com.example;

import java.util.concurrent.Future;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.fxmisc.flowless.VirtualizedScrollPane;
import org.fxmisc.richtext.CodeArea;
import org.fxmisc.richtext.LineNumberFactory;
import org.lwjgl.glfw.GLFW;

import com.example.TextEditor.Interpreter.Highlighter;
import com.example.TextEditor.Interpreter.interpreter.RuntimeError;
import com.example.shape.Colors;
import com.example.shape.Cube;
import com.example.shape.MaterialEnum;
import com.example.shape.OrbitCamera;
import com.example.shape.Puzzel;
import com.example.shape.Size;
import com.example.shape.Voxel;
import com.example.shape.VoxelGrid;
import com.example.shape.VoxelGridInterface;

import com.jme3.app.SimpleApplication;
import com.jme3.light.AmbientLight;
import com.jme3.light.DirectionalLight;
import com.jme3.math.ColorRGBA;
import com.jme3.math.Vector3f;
import com.jme3.renderer.Camera;
import com.jme3.renderer.ViewPort;
import com.jme3.scene.Node;
import com.jme3.shadow.DirectionalLightShadowRenderer;
import com.jme3.shadow.EdgeFilteringMode;
import com.jme3.system.SystemListener;
import com.jme3.system.lwjgl.LwjglWindow;

import javafx.animation.PauseTransition;
import javafx.application.Platform;
import javafx.scene.Scene;
import javafx.scene.control.TextArea;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.Priority;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;
import javafx.stage.StageStyle;
import javafx.util.Duration;

public class App extends SimpleApplication implements SystemListener{
    public String getGreeting() {
        return "Hello World!";
    }

    public static void main(String[] args) {
        javafx.application.Platform.startup(() -> {});
        App app = new App();
        app.start();
        javafx.application.Platform.exit();
    }

    // code Editor
    private Node topRootNode;
    private Node bottomRootNode;
    private CodeArea codeEditor;
    private String code;
    private TextArea errorDisplay;
    private Stage editorStage; 
    private Future<?> errorCheck = null;
    private PauseTransition codeRunDelay = new PauseTransition(Duration.seconds(2));
    private Puzzel puzzel;

    @Override
    public void simpleInitApp() {
        // stacking two screens

        topRootNode = new Node("top");
        bottomRootNode = new Node("bottom");

        Camera topCam = cam.clone();
        topCam.setLocation(new Vector3f(0, 0, 5));
        topCam.lookAt(Vector3f.ZERO, Vector3f.UNIT_Y);
        topCam.setViewPort(0.5f, 1f, 0.5f, 1f);

        ViewPort topViewPort = renderManager.createMainView("TopViewPort", topCam);
        topViewPort.setBackgroundColor(ColorRGBA.fromRGBA255(246, 242, 232, 255));
        topViewPort.setClearFlags(true, true, true);
        topViewPort.attachScene(topRootNode);

        Camera bottomCam = cam.clone();
        bottomCam.setLocation(new Vector3f(0, 0, 5));
        bottomCam.lookAt(Vector3f.ZERO, Vector3f.UNIT_Y);
        bottomCam.setViewPort(0.5f, 1f, 0f, 0.5f);

        ViewPort bottomViewPort = renderManager.createMainView("BottomViewPort", bottomCam);
        bottomViewPort.setBackgroundColor(ColorRGBA.fromRGBA255(246, 242, 232, 255));
        bottomViewPort.setClearFlags(true, true, true);
        bottomViewPort.attachScene(bottomRootNode);

        // making lights
        DirectionalLight topSun = new DirectionalLight();
        topSun.setDirection(new Vector3f(-1, -0.33f, -1).normalizeLocal());
        topSun.setColor(ColorRGBA.White.mult(1.5f));

        AmbientLight topAmbientLight = new AmbientLight();
        topAmbientLight.setColor(ColorRGBA.White.mult(0.4f));

        topRootNode.addLight(topSun);
        topRootNode.addLight(topAmbientLight);

        DirectionalLight bottomSun = new DirectionalLight();
        bottomSun.setDirection(new Vector3f(-1f, -0.333f, -1f).normalizeLocal());
        bottomSun.setColor(ColorRGBA.White.mult(1.5f));

        AmbientLight bottomAmbientLight = new AmbientLight();
        bottomAmbientLight.setColor(ColorRGBA.White.mult(0.4f));

        bottomRootNode.addLight(bottomSun);
        bottomRootNode.addLight(bottomAmbientLight);

        // making shadow
        DirectionalLightShadowRenderer topShadowRenderer = new DirectionalLightShadowRenderer(assetManager, 2048, 3);
        topShadowRenderer.setShadowZExtend(50f);
        topShadowRenderer.setLight(topSun);
        topShadowRenderer.setShadowIntensity(0.4f);
        topShadowRenderer.setEdgeFilteringMode(EdgeFilteringMode.Bilinear);

        topViewPort.addProcessor(topShadowRenderer);

        DirectionalLightShadowRenderer bottomShadowRenderer = new DirectionalLightShadowRenderer(assetManager, 2048, 3);
        bottomShadowRenderer.setShadowZExtend(50f);
        bottomShadowRenderer.setLight(bottomSun);
        bottomShadowRenderer.setShadowIntensity(0.4f);
        bottomShadowRenderer.setEdgeFilteringMode(EdgeFilteringMode.Bilinear);

        bottomViewPort.addProcessor(bottomShadowRenderer);

        VoxelGridInterface bottomFunc = new VoxelGridInterface() {
            @Override
            public Voxel determineVoxel(int x, int y, int z, int frame) {
                if(y == 0 || y == 4){ 
                    return new Cube(x, y, z, MaterialEnum.MATTE, Colors.values()[(x + y + z) % 5], Size.LARGE, assetManager); 
                }
                return null;
            }
        };

        puzzel = new Puzzel(
            new VoxelGrid(5, 5, 5, "puzzel-1-target"), 
            bottomFunc,
            new VoxelGrid(5, 5, 5, "puzzel-1-user"), 
            "puzzel-1", this
        );

        this.enqueue(() -> {
            puzzel.intializeTargetGrid(bottomRootNode);
            puzzel.intializeUserGrid(topRootNode);
        });

        OrbitCamera topOrbitCamera = new OrbitCamera(topRootNode, topCam, inputManager);
        OrbitCamera bottomOrbitCamera = new OrbitCamera(bottomRootNode, bottomCam, inputManager);

        flyCam.setDragToRotate(true);
        flyCam.setEnabled(false);
        inputManager.setCursorVisible(true);
        this.setPauseOnLostFocus(false);

        codeRunDelay.setOnFinished(event -> runCode(code));

        Platform.runLater( () -> { intializeCodeEditor();} );

        long windowHandle = ((LwjglWindow)getContext()).getWindowHandle();

        GLFW.glfwSetWindowPosCallback(windowHandle, 
            (window, xpos, ypos) -> {
                Platform.runLater(
                    () -> {
                        editorStage.setX(xpos);
                        editorStage.setY(ypos);
                    }
                );
            }
        );
    }

    @Override
    public void simpleUpdate(float tpf) {
        topRootNode.updateLogicalState(tpf);
        topRootNode.updateGeometricState();

        bottomRootNode.updateLogicalState(tpf);
        bottomRootNode.updateGeometricState();

        if (errorCheck != null && errorCheck.isDone()) {
            try { errorCheck.get(); } 
            catch (RuntimeError e) { Platform.runLater(() -> errorDisplay.setText(e.getMessage()) ); }
            catch (Exception e) { Platform.runLater(() -> errorDisplay.setText(e.getMessage()) ); }

            errorCheck = null;
        }
    }

    @Override
    public void reshape(int w, int h) {
        Platform.runLater(
            () -> {
                editorStage.setWidth((int)(this.getContext().getSettings().get("Width")) / 2);
                editorStage.setHeight((int)(this.getContext().getSettings().get("Height")));
            }
        );
    }

    private void runCode(String newCode){
        try {
            errorCheck = this.enqueue(
                () -> { 
                    try {
                        puzzel.updateUserGrid(newCode);

                        errorDisplay.setText("");
                    } 
                    catch (RuntimeError r) { errorDisplay.setText(r.getMessage()); } 
                    catch (Exception e) { errorDisplay.setText("Syntax Error: " + e.getMessage()); }
                    return null;
                }
            );

            errorDisplay.setText("");
        } 
        catch (RuntimeError r) { errorDisplay.setText(r.getMessage());} 
        catch (Exception e) { errorDisplay.setText("Syntax Error: " + e.getMessage());}
    }

    public void intializeCodeEditor(){
        codeEditor = new CodeArea();
        codeEditor.setParagraphGraphicFactory(LineNumberFactory.get(codeEditor));

        errorDisplay = new TextArea();
        errorDisplay.setEditable(false);
        errorDisplay.setWrapText(true);
        errorDisplay.setPrefHeight(70);
        errorDisplay.setStyle(
            "-fx-control-inner-background: #2b2b2b;" +
            "-fx-font-family: Consolas;" +
            "-fx-text-fill: red;" +
            "-fx-font-size: 14px;"
        );
        
        codeEditor.textProperty().addListener((obs, oldText, newText) -> {
            code = newText;
            codeEditor.setStyleSpans(0, Highlighter.highlight(code));
            codeRunDelay.stop();
            codeRunDelay.play();
        });

        addListenerToCodeEditor();

        // ui
        VirtualizedScrollPane<CodeArea> vsPane = new VirtualizedScrollPane<>(codeEditor);

        VBox layout = new VBox(vsPane, errorDisplay);
        VBox.setVgrow(vsPane, Priority.ALWAYS);

        Scene scene = new Scene(layout);
        scene.getStylesheets().add(getClass().getResource("/style.css").toExternalForm());

        editorStage = new Stage(StageStyle.UNDECORATED);
        editorStage.setScene(scene);
        editorStage.setAlwaysOnTop(true);

        editorStage.setWidth(settings.getWidth() / 2.0);
        editorStage.setHeight(settings.getHeight());

        long windowHandle = ((LwjglWindow)getContext()).getWindowHandle();

        int x[] = new int[1];
        int y[] = new int[1];
        GLFW.glfwGetWindowPos(windowHandle, x, y);
        editorStage.setX(x[0]);
        editorStage.setY(y[0]);

        editorStage.show();
    }

    private void addListenerToCodeEditor(){
        codeEditor.addEventHandler(
            KeyEvent.KEY_TYPED, e -> {
                String character = e.getCharacter();
                int caret = codeEditor.getCaretPosition();

                switch (character) {
                    case "(": 
                        codeEditor.insertText(caret, ")"); 
                        codeEditor.moveTo(caret); 
                        break;
                    case "{": 
                        codeEditor.insertText(caret, "}"); 
                        codeEditor.moveTo(caret); 
                        break;
                }
            }
        );

        codeEditor.addEventHandler(
            KeyEvent.KEY_PRESSED, e -> {
                int caret = codeEditor.getCaretPosition();

                if(e.getCode() == KeyCode.TAB) {
                    e.consume();
                    codeEditor.replaceText(caret - 1, caret, "    ");
                }

                if(e.getCode() == KeyCode.ENTER) {
                    Pattern whiteSpace = Pattern.compile("^\\s+");
                    int currentParagraph = codeEditor.getCurrentParagraph();
                    if (currentParagraph > 0) {
                        String previousLine = codeEditor.getParagraph(currentParagraph - 1).getText();
                        
                        Matcher m = whiteSpace.matcher(previousLine);
                        if (m.find()) {
                            String indentation = m.group();
                            codeEditor.insertText(codeEditor.getCaretPosition(), indentation);
                            e.consume();
                        }
                    }
                }
            }
        );
    }
}
